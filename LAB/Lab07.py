# -*- coding: utf-8 -*-
"""Lab07.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1orGh4GsMRuMA7xaHyEUpctmOnXvJfy7e
"""

#Exercise 1
def calculate_thieves(day):
    if day == 1:
        return 1
    else:
        return day + calculate_thieves(day - 1)

def calculate_days():
    total_thieves = 40
    day = 1

    while total_thieves >= day:
        total_thieves -= calculate_thieves(day)
        if total_thieves < day:
            break
        day += 1

    return day

thieves_sent_on_day_5 = calculate_thieves(5)
print("Thieves sent on day 5:", thieves_sent_on_day_5)

days_until_no_more_thieves = calculate_days()
print("Days until no more thieves can be sent:", days_until_no_more_thieves)

#Exercise 2
def richest(men):
    if len(men) == 1:
        return men[0]
    else:
        current_richest = men[0]
        previous_richest = richest(men[1:])
        if current_richest > previous_richest:
            return current_richest
        else:
            return previous_richest


men = [10, 5, 8, 12, 3]
richest_man = richest(men)
print("The richest man:", richest_man)

#Exercise 3
def binomial_coefficient(n, k):
    C = [[0 for _ in range(k+1)] for _ in range(n+1)]
    for i in range(n+1):
        for j in range(min(i, k)+1):
            if j == 0 or j == i:
                C[i][j] = 1
            else:
                C[i][j] = C[i-1][j-1] + C[i-1][j]
    return C[n][k]

def find_k(n, target):
    min_diff = float('inf')
    best_k = -1
    for k in range(n+1):
        diff = abs(binomial_coefficient(n, k) - target)
        if diff < min_diff:
            min_diff = diff
            best_k = k
    return best_k

n = 50
target = 1000
k = find_k(n, target)
print(f"The best k is {k}")

#Exxercise 4
def waytochooseP(n, k):
    if k == 0 or k == n:
        return 1
    else:
        result = 1
        for i in range(n, n - k, -1):
            result *= i
        return result

def find_k():
    n = 50
    target_permutations = 10000
    closest_diff = float('inf')
    closest_k = None

    for k in range(n + 1):
        permutations = waytochooseP(n, k)
        diff = abs(permutations - target_permutations)
        if diff < closest_diff:
            closest_diff = diff
            closest_k = k

    return closest_k

closest_k = find_k()
print("The value of k that gives the number of permutations closest to 10000:", closest_k)

#Exercise 5
def total_characters(story_number):
    if story_number == 0:
        return 1
    else:
        return 2 * total_characters(story_number - 1)

def calculate_total_characters():
    total_stories = 547
    total_chars = total_characters(total_stories)
    return total_chars

total_chars = calculate_total_characters()
print("Total characters in Scheherazade's stories:", total_chars)

#Exercise 6
def fibonacci(n):
    if n < 2:
        return n
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

n = 10
fib_number = fibonacci(n)
print("The", n, "th number in the Fibonacci sequence is:", fib_number)

#Exercise 7
def towerOfHanoi(A, B, C, n):
    if n > 0:
        towerOfHanoi(A, C, B, n - 1)

        disk = A[1].pop()
        C[1].append(disk)

        towerOfHanoi(B, A, C, n - 1)

A = [['A'], [5, 4, 3, 2, 1]]
B = [['B'], []]
C = [['C'], []]
n = len(A[1])

print("Initial state:")
print("A:", A)
print("B:", B)
print("C:", C)
print()

towerOfHanoi(A, B, C, n)

print("Final state:")
print("A:", A)
print("B:", B)
print("C:", C)